<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Accuracy Camera OCR Scanner</title>
    <!-- Tesseract.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <!-- OpenCV.js CDN -->
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        video {
            width: 100%;
            height: auto;
            max-height: 80vh;
            background-color: #000;
        }
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 200px;
            transform: translate(-50%, -50%);
            border: 4px solid red;
            box-sizing: border-box;
            pointer-events: none;
            transition: border-color 0.3s ease;
        }
        #controls {
            margin-top: 20px;
            text-align: center;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #output {
            margin-top: 20px;
            width: 80%;
            max-width: 600px;
            height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            resize: none;
            font-size: 14px;
            overflow-y: auto;
        }
        #errorMsg {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255,0,0,0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="errorMsg"></div>
    <div id="container">
        <video id="video" autoplay playsinline></video>
        <div id="overlay"></div>
        <div id="controls">
            <button id="start-button">Start Scanner</button>
            <textarea id="output" placeholder="Extracted text will appear here..." readonly></textarea>
        </div>
    </div>

    <script>
        // References to DOM elements
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const startButton = document.getElementById('start-button');
        const output = document.getElementById('output');
        const errorMsg = document.getElementById('errorMsg');

        let stream = null;
        let scanning = false;
        let scanInterval = null;
        let cvReady = false;

        // Wait for OpenCV.js to be ready
        function onOpenCvReady() {
            if (cv.getBuildInformation) { // Simple check to see if OpenCV is loaded
                console.log('OpenCV.js is ready.');
                cvReady = true;
            } else {
                console.error('Failed to load OpenCV.js.');
                showError('Failed to load OpenCV.js.');
            }
        }

        // Load OpenCV.js and set up readiness callback
        if (typeof cv !== 'undefined') {
            cv['onRuntimeInitialized'] = onOpenCvReady;
        } else {
            console.error('OpenCV.js not found.');
            showError('OpenCV.js failed to load.');
        }

        // Function to display error messages
        function showError(message) {
            errorMsg.innerText = message;
            errorMsg.style.display = 'block';
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, 5000);
        }

        // Function to initialize camera
        async function initCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { exact: "environment" } },
                    audio: false
                });
                video.srcObject = stream;
            } catch (err) {
                console.error(err);
                showError('Unable to access the rear camera. Please check permissions or try a different device.');
            }
        }

        // Function to preprocess image using OpenCV.js
        function preprocessImage(mat) {
            // Convert to grayscale
            cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);

            // Apply Gaussian Blur to reduce noise
            cv.GaussianBlur(mat, mat, new cv.Size(5, 5), 0);

            // Apply adaptive thresholding
            cv.adaptiveThreshold(mat, mat, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

            // Optionally, you can perform morphological operations to enhance text
            let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
            cv.morphologyEx(mat, mat, cv.MORPH_CLOSE, kernel);
            kernel.delete();

            return mat;
        }

        // Function to start scanning
        function startScanning() {
            if (scanning || !cvReady) return;

            scanning = true;
            startButton.disabled = true;
            startButton.innerText = 'Scanning...';
            output.value = ''; // Clear previous output

            scanInterval = setInterval(async () => {
                if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                    console.warn('Video not ready');
                    return;
                }

                // Create a hidden canvas to capture the frame
                const canvas = document.createElement('canvas');
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                canvas.width = videoWidth;
                canvas.height = videoHeight;
                const ctx = canvas.getContext('2d');

                ctx.drawImage(video, 0, 0, videoWidth, videoHeight);

                // Get overlay and container dimensions
                const overlayRect = overlay.getBoundingClientRect();
                const containerRect = document.getElementById('container').getBoundingClientRect();

                // Calculate scaling factors between video display size and actual video size
                const scaleX = videoWidth / containerRect.width;
                const scaleY = videoHeight / containerRect.height;

                // Calculate ROI coordinates
                const roiX = (overlayRect.left - containerRect.left) * scaleX;
                const roiY = (overlayRect.top - containerRect.top) * scaleY;
                const roiWidth = overlayRect.width * scaleX;
                const roiHeight = overlayRect.height * scaleY;

                // Extract ROI from the video frame
                let imageData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight);

                // Create OpenCV.js Mat from imageData
                let src = cv.matFromImageData(imageData);
                let processed = preprocessImage(src.clone());

                // Convert processed Mat back to ImageData
                let processedImageData = new ImageData(new Uint8ClampedArray(processed.data), processed.cols, processed.rows);
                src.delete();
                processed.delete();

                // Create a temporary canvas for OCR
                const roiCanvas = document.createElement('canvas');
                const scaleFactor = 3; // Increase scale factor for better OCR accuracy
                roiCanvas.width = processedImageData.width * scaleFactor;
                roiCanvas.height = processedImageData.height * scaleFactor;
                const roiCtx = roiCanvas.getContext('2d');

                // Draw the processed image scaled up
                roiCtx.imageSmoothingEnabled = true;
                roiCtx.imageSmoothingQuality = 'high';
                roiCtx.putImageData(processedImageData, 0, 0);
                roiCtx.drawImage(roiCanvas, 0, 0, roiCanvas.width, roiCanvas.height);

                // Convert the canvas to a blob for OCR
                roiCanvas.toBlob(async (blob) => {
                    if (blob) {
                        try {
                            const { data: { text }, confidence } = await Tesseract.recognize(blob, 'eng', { 
                                logger: m => console.log(m),
                                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,/-()& ',
                            });

                            console.log(`Confidence: ${confidence}`);
                            console.log(`Extracted Text: "${text.trim()}"`);

                            if (text.trim().length > 0) {
                                overlay.style.borderColor = 'green';
                                // Append the extracted text to the output field if not already present
                                if (!output.value.includes(text.trim())) {
                                    output.value += text.trim() + '\n';
                                }
                            } else {
                                overlay.style.borderColor = 'red';
                                // Optionally, notify the user or take other actions
                                // output.value = 'No text detected.';
                            }
                        } catch (err) {
                            console.error('Tesseract.js error:', err);
                            showError('An error occurred while processing the image.');
                            overlay.style.borderColor = 'red';
                        }
                    }
                }, 'image/png');
            }, 1000); // Scan every 1 second
        }

        // Function to stop scanning
        function stopScanning() {
            scanning = false;
            startButton.disabled = false;
            startButton.innerText = 'Start Scanner';
            clearInterval(scanInterval);
            overlay.style.borderColor = 'red';
        }

        // Initialize camera on page load
        window.addEventListener('load', () => {
            initCamera();
        });

        // Handle start button click
        startButton.addEventListener('click', () => {
            if (!scanning) {
                startScanning();
            } else {
                stopScanning();
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            clearInterval(scanInterval);
        });
    </script>
</body>
</html>
